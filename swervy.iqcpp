{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\nmotor fro = motor(PORT1, false);\nmotor frp = motor(PORT2, false);\nmotor flo = motor(PORT7, false);\nmotor flp = motor(PORT8, false);\nmotor bro = motor(PORT6, false);\nmotor brp = motor(PORT5, false);\nmotor blo = motor(PORT12, false);\nmotor blp = motor(PORT11, false);\ncontroller Controller = controller();\ncolorsensor flc = colorsensor(PORT9);\ncolorsensor blc = colorsensor(PORT10);\ncolorsensor frc = colorsensor(PORT3);\ncolorsensor brc = colorsensor(PORT4);\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       {author}                                                  \n//    Created:      {date}                                                    \n//    Description:  IQ project                                                \n//                                                                            \n//----------------------------------------------------------------------------\n\n// Include the IQ Library\n#include \"iq_cpp.h\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\nvoid debug() {\n  while (true) {\n    Brain.Screen.setCursor(1,1);\n    Brain.Screen.print(\"Motor1: %f\", fro.position(degrees));\n    Brain.Screen.setCursor(2,1);  \n    Brain.Screen.print(\"Motor2: %f\", frp.position(degrees));\n    Brain.Screen.setCursor(3,1);  \n    Brain.Screen.print(\"bright: %d\",flc.brightness());\n      \n    wait(10, msec);\n      \n      \n      Brain.Screen.clearScreen();\n  }\n  }\n  \nclass hub {\n  private:\n    motor* m1;\n    motor* m2;\n  \n    float targetRot;\n    float driveSpeed;\n    float preverror1;\n    float preverror2;\n      \n  public:\n    //constructor\n    hub(motor& m1, motor& m2) {\n      hub::m1 = &m1;\n      hub::m2 = &m2;\n          \n      m1.setPosition(0, degrees);      \n       m2.setPosition(0, degrees);      \n      targetRot = 0;      \n       driveSpeed = 10;      \n       preverror1 = 0;      \n       preverror2 = 0;    \n      }    \n          \n     //movement functions    \n     void spinTo(float rot) {\n      hub::targetRot = rot;\n      }\n            \n       void setSpeed(float speed) {\n          hub::driveSpeed = speed;\n        }\n              \n        float pid(float error, bool ism1) {\n              //deadzone\n                if(error < 3) return 0;\n                \n              float p = error * 0.6; //kp\n              float d = 0;\n                \n              if(ism1) d = (error - hub::preverror1);\n              else d = (error - hub::preverror2);\n              \n              \n              d *= 0.33; //kd\n              \n              if(ism1) hub::preverror1 = error;      \n              else hub::preverror2 = error;\n              return p + d;\n              }\n              \n              void update() {\n                //get the motors stored in the memory addresses recorded by the hub pointers\n                motor temp1 = *hub::m1;\n                motor temp2 = *hub::m2;\n                \n                //370 is the distance the two motors have to be apart, encoder wise, for the wheel to be facing 180 degrees from its starting position\n                float offset = 370 * (targetRot/180);\n                float target1 = hub::pid((temp2.position(degrees)-temp1.position(degrees)+offset), true);\n                float target2 = hub::pid((temp1.position(degrees)-temp2.position(degrees)-offset), false);\n                \n                float speed = hub::driveSpeed;\n                if(speed-target1 > 100 || speed-target1 < -100) target2 -= speed-target1>0 ? speed-target1 : target1-speed;\n                if(speed-target2 > 100 || speed - target2 < -100) target1 -= speed-target2>0 ? speed-target2 : target2-speed;\n                \n                temp1.setVelocity(hub::driveSpeed - target1, percent);\n                temp2.setVelocity(hub::driveSpeed - target2, percent);\n                \n                temp1.spin(reverse);\n                temp2.spin(reverse);\n                \n                //wait(15, msec);\n  }\n};\n\n\n\nvoid sequence() {\n  frc.setLight(100,percent);\n  flc.setLight(100,percent);\n  brc.setLight(100,percent);\n  blc.setLight(100,percent);\n  \n  while( frc.brightness()>30) {\n    fro.spin(forward,5,pct);\n    frp.spin(reverse,5,pct);\n    wait(10,msec);\n  }\n  while( frc.brightness()>30) {\n    fro.spin(reverse,1,pct);\n    frp.spin(forward,1,pct);\n    wait(10,msec);\n  }\n  fro.stop();\n  frp.stop();\n  while( flc.brightness()>25) {\n    flo.spin(forward,5,pct);\n    flp.spin(reverse,5,pct);\n    wait(10,msec);\n  }\n  while( flc.brightness()>25) {\n    flo.spin(reverse,1,pct);\n    flp.spin(forward,1,pct);\n    wait(10,msec);\n  }\n  flo.stop();\n  flp.stop();\n  while( brc.brightness()>25) {\n    bro.spin(forward,5,pct);\n    brp.spin(reverse,5,pct);\n    wait(10,msec);\n  }\n  while( brc.brightness()>25) {\n    bro.spin(reverse,1,pct);\n    brp.spin(forward,1,pct);\n    wait(10,msec);\n  }\n  bro.stop();\n  brp.stop();\n  while( blc.brightness()>18) {\n    blo.spin(forward,5,pct);\n    blp.spin(reverse,5,pct);\n    wait(10,msec);\n  }\n  while( blc.brightness()>18) {\n    blo.spin(reverse,1,pct);\n    blp.spin(forward,1,pct);\n    wait(10,msec);\n  }\n  blo.stop();\n  blp.stop();\n  \n  //frc.setLight(0,percent);\n  //flc.setLight(0,percent);\n  //brc.setLight(0,percent);\n  //blc.setLight(0,percent);\n\n  blo.setPosition(0,degrees);\n  bro.setPosition(0,degrees);\n  blp.setPosition(0,degrees);\n  brp.setPosition(0,degrees);\n  flo.setPosition(0,degrees);\n  fro.setPosition(0,degrees);\n  flp.setPosition(0,degrees);\n  frp.setPosition(0,degrees);\n}\n                \nint main() {\n   thread t(debug);\n   \n  \n\n  sequence();\n\n\n   hub frontlh(flp, flo);\n   hub frontrh(frp, fro);\n   hub righth(brp, bro);\n   hub lefth(blp, blo);\n                  \n                 \n   while(true) {\n\n     if(Controller.ButtonEDown.pressing()) {\n       sequence();\n     }\n\n     float x = Controller.AxisB.position();\n     float y = Controller.AxisA.position();\n     float speed = sqrt((x*x) + (y*y));\n                    \n     float rot = atan2(y, x);\n     rot = -(rot / 3.14159) * 180;\n     rot -= 180; //get it oriented properly\n                    \n     frontlh.spinTo(rot);\n     frontrh.spinTo(rot);\n     righth.spinTo(rot);\n     lefth.spinTo(rot);\n     frontlh.setSpeed(speed);\n     frontrh.setSpeed(speed);\n     righth.setSpeed(speed);\n     lefth.setSpeed(speed);\n     frontlh.update();\n     frontrh.update();\n     righth.update();\n     lefth.update();\n                    \n     wait(15, msec);\n     \n  }\n}\n                    ","textLanguage":"cpp","rconfig":[{"port":[1],"name":"fro","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[2],"name":"frp","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[7],"name":"flo","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[8],"name":"flp","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[6],"name":"bro","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[5],"name":"brp","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[12],"name":"blo","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[11],"name":"blp","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[],"name":"Controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[9],"name":"flc","customName":true,"deviceType":"Color","deviceClass":"colorsensor","setting":{},"triportSourcePort":22},{"port":[10],"name":"blc","customName":true,"deviceType":"Color","deviceClass":"colorsensor","setting":{},"triportSourcePort":22},{"port":[3],"name":"frc","customName":true,"deviceType":"Color","deviceClass":"colorsensor","setting":{},"triportSourcePort":22},{"port":[4],"name":"brc","customName":true,"deviceType":"Color","deviceClass":"colorsensor","setting":{},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20220726.10.00.00","appVersion":"2.4.5","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Physical"}